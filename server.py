from concurrent import futures
import logging
import grpc
import auth_pb2, auth_pb2_grpc
import sqlite3
import jwt
import time

# constants
PORT = str("50051")
JWT_SECRET = str("rpc heaven")
JWT_ALGO = str("HS256")
JWT_EXPIRATION_TIME = int(3600)

def cleanseString(input):
    """Returns an alphanumeric-only output."""
    return str(''.join(e for e in input if e.isalnum()))

# Implementation of the authentication service.
class Auth(auth_pb2_grpc.AuthServicer):
    def Login(self, request, context):
        # sqlite
        con = sqlite3.connect("users.db")
        cur = con.cursor()

        # prevent sql injection
        user = cleanseString(request.user)

        lookup = cur.execute(f"SELECT pwd FROM users WHERE user='{user}' AND pwd='{request.pwd}'").fetchone()

        if lookup == None:
            return auth_pb2.LoginResponse(jwt=None)

        # timestamps
        currTime = int(time.time())
        validThru = currTime + JWT_EXPIRATION_TIME

        claims = {
            "user": request.user,
            "pwd": request.pwd,
            "createdAt": currTime,
            "expiresAt": validThru,
        }

        token = jwt.encode(claims, JWT_SECRET, algorithm=JWT_ALGO)

        # update token
        cur.execute(f"UPDATE users SET access_token='{token}' WHERE user='{user}'");
        con.commit()

        return auth_pb2.LoginResponse(jwt=token)

    def Register(self, request, context):
        # sqlite
        con = sqlite3.connect("users.db")
        cur = con.cursor()

        # prevent sql injection
        user = cleanseString(request.user)

        lookup = cur.execute(f"SELECT user FROM users WHERE user='{user}'").fetchone()
        if lookup != None:
            return auth_pb2.RegisterResponse(result=f'User {user} already exists, could not register')

        # save the user
        cur.execute(f"INSERT INTO users (user, pwd) VALUES ('{user}', '{request.pwd}')");
        con.commit()

        return auth_pb2.RegisterResponse(result=f'Registered as {user}')

    def Validate(self, request, context):
        # sqlite
        con = sqlite3.connect("users.db")
        cur = con.cursor()
        
        # empty string would match on all the users who never logged in
        if request.jwt == None or request.jwt == '':
            return auth_pb2.ValidateResponse(result=False)

        lookup = cur.execute(f"SELECT user FROM users WHERE access_token='{request.jwt}'").fetchone()

        # fake token
        if lookup == None:
            return auth_pb2.ValidateResponse(result=False)

        claims = jwt.decode(request.jwt, JWT_SECRET, algorithms=[JWT_ALGO])

        # expiration
        if claims["expiresAt"] < int(time.time()):
            return auth_pb2.ValidateResponse(result=False)
        
        return auth_pb2.ValidateResponse(result=True)

    
def serve():
    server = grpc.server(futures.ThreadPoolExecutor(max_workers=10))
    auth_pb2_grpc.add_AuthServicer_to_server(Auth(), server)
    server.add_insecure_port('[::]:' + PORT)
    server.start()
    print("Server started, listening on " + PORT)
    server.wait_for_termination()

if __name__ == '__main__':
    logging.basicConfig()
    serve()
